{"version":3,"file":"listenjs.js","sources":["../src/types.ts","../src/destroy-dom.ts","../src/events.ts","../src/dispatcher.ts","../src/set-prop.ts","../src/mount-host-component.ts","../src/app.ts","../src/utils/arrays.ts","../src/create-element.ts"],"sourcesContent":["enum DOMType {\n  TEXT = \"text\",\n  ELEMENT = \"element\",\n  FRAGMENT = \"fragment\",\n}\n\ninterface Props {\n  [key: string]: any;\n  on?: Record<string, EventListener>; // Event listeners\n  class?: string | string[]; // CSS classes\n  style?: Record<string, string>; // Inline styles\n}\n\n// Fiber node types\ninterface TextFiber {\n  type: DOMType.TEXT;\n  value: string;\n  domElement?: Text;\n}\n\ninterface ElementFiber {\n  type: DOMType.ELEMENT;\n  tag: string;\n  props: Props;\n  children: Fiber[];\n  domElement?: HTMLElement;\n  listeners?: Record<string, EventListener>;\n}\n\ninterface FragmentFiber {\n  type: DOMType.FRAGMENT;\n  children: Fiber[];\n  domElement?: Node; // Parent node for fragment\n}\n\ntype Fiber = TextFiber | ElementFiber | FragmentFiber;\ntype FiberChild = string | Fiber; // Acceptable child types\n\nexport {\n  DOMType,\n  ElementFiber,\n  Fiber,\n  FiberChild,\n  FragmentFiber,\n  Props,\n  TextFiber,\n};\n","import { removeEventListeners } from \"./events\";\nimport {\n  DOMType,\n  ElementFiber,\n  Fiber,\n  FragmentFiber,\n  TextFiber,\n} from \"./types\";\n\nfunction destroyDOM(fiber: Fiber) {\n  const { type } = fiber;\n\n  switch (type) {\n    case DOMType.TEXT: {\n      removeTextNode(fiber);\n      break;\n    }\n    case DOMType.ELEMENT: {\n      removeElementNode(fiber);\n      break;\n    }\n    case DOMType.FRAGMENT: {\n      removeFragmentNodes(fiber);\n      break;\n    }\n\n    default: {\n      throw new Error(\"Cannot destroy DOM of type: \", type);\n    }\n  }\n\n  delete fiber.domElement;\n}\n\nfunction removeTextNode(fiber: TextFiber) {\n  const { domElement } = fiber;\n  if (domElement) {\n    domElement.remove();\n  }\n}\n\nfunction removeElementNode(fiber: ElementFiber) {\n  const { domElement, children, listeners } = fiber;\n\n  if (!domElement) return;\n\n  domElement.remove();\n  children.forEach(destroyDOM);\n\n  if (listeners) {\n    removeEventListeners(listeners, domElement);\n    delete fiber.listeners;\n  }\n}\n\nfunction removeFragmentNodes(fiber: FragmentFiber) {\n  const { children } = fiber;\n  children.forEach(destroyDOM);\n}\n\nexport { destroyDOM };\n","function attachEventListener(\n  eventType: string,\n  handler: EventListener,\n  domElement: HTMLElement\n) {\n  domElement.addEventListener(eventType, handler);\n\n  return handler;\n}\n\nfunction attachEventListeners(\n  listeners: Record<string, EventListener> = {},\n  domElement: HTMLElement\n) {\n  const attachedListeners: Record<string, EventListener> = {};\n\n  Object.entries(listeners).forEach(([eventType, handler]) => {\n    const listener = attachEventListener(eventType, handler, domElement);\n    attachedListeners[eventType] = listener;\n  });\n\n  return attachedListeners;\n}\n\nfunction removeEventListeners(\n  listeners: Record<string, EventListener> = {},\n  domElement: HTMLElement\n) {\n  Object.entries(listeners).forEach(([eventType, handler]) => {\n    domElement.removeEventListener(eventType, handler);\n  });\n}\n\nexport { attachEventListener, attachEventListeners, removeEventListeners };\n","type VoidFunction = (payload?: object) => void;\n\nclass Dispatcher {\n  #subs: Map<string, VoidFunction[]> = new Map();\n  #afterHandlers: VoidFunction[] = [];\n\n  subscribe(commandName: string, handler: VoidFunction) {\n    if (!this.#subs.has(commandName)) {\n      this.#subs.set(commandName, []);\n    }\n\n    const handlers = this.#subs.get(commandName);\n    if (handlers?.includes(handler)) {\n      return () => {};\n    }\n    handlers?.push(handler);\n\n    return () => {\n      if (handlers) {\n        const index = handlers?.indexOf(handler);\n        handlers?.splice(index, 1);\n      }\n    };\n  }\n\n  afterEveryCommand(handler: VoidFunction) {\n    this.#afterHandlers.push(handler);\n    return () => {\n      const index = this.#afterHandlers.indexOf(handler);\n      this.#afterHandlers.splice(index, 1);\n    };\n  }\n\n  dispatch(commandName: string, payload: object) {\n    if (this.#subs.has(commandName)) {\n      this.#subs.get(commandName)?.forEach((handler) => handler(payload));\n    } else {\n      console.warn(`No handlers found for command: ${commandName}`);\n    }\n\n    this.#afterHandlers.forEach((handler) => handler());\n  }\n}\n\nexport { Dispatcher };\n","function setProp(domElement: HTMLElement, attrs: Record<string, unknown>) {\n  const { class: className, style, ...restAttrs } = attrs;\n\n  if (typeof className === \"string\" || Array.isArray(className)) {\n    setClass(domElement, className);\n  }\n\n  if (style) {\n    Object.entries(style).forEach(([key, value]) => {\n      if (typeof value === \"string\") {\n        setStyle(domElement, key, value);\n      }\n    });\n  }\n\n  for (const [key, value] of Object.entries(restAttrs)) {\n    if (typeof value === \"string\") {\n      setValueForAttribute(domElement, key, value);\n    }\n  }\n}\n\nfunction setClass(domElement: HTMLElement, className: string | string[]) {\n  domElement.className = \"\";\n\n  if (typeof className === \"string\") {\n    domElement.className = className;\n  }\n\n  if (Array.isArray(className)) {\n    domElement.classList.add(...className);\n  }\n}\n\nfunction setStyle(domElement: HTMLElement, key: string, value: string) {\n  domElement.style[key] = value;\n}\n\nfunction removeStyle(domElement: HTMLElement, key: string) {\n  domElement.style[key] = null;\n}\n\nfunction setValueForAttribute(\n  domElement: HTMLElement,\n  key: string,\n  value: string\n) {\n  if (value == null) {\n    removeValueForAttribute(domElement, key);\n  } else if (key.startsWith(\"data-\")) {\n    domElement.setAttribute(key, value);\n  } else {\n    domElement[key] = value;\n  }\n}\n\nfunction removeValueForAttribute(domElement: HTMLElement, key: string) {\n  domElement[key] = null;\n  domElement.removeAttribute(key);\n}\n\nexport { setProp };\n","import { attachEventListeners } from \"./events\";\nimport { setProp } from \"./set-prop\";\nimport {\n  DOMType,\n  ElementFiber,\n  Fiber,\n  FragmentFiber,\n  Props,\n  TextFiber,\n} from \"./types\";\n\nfunction mountHostComponent(fiber: Fiber, parentInstance: Node) {\n  if (parentInstance == undefined) {\n    throw new Error(`\n      \"Parent element is not defined: ${parentInstance}`);\n  }\n\n  switch (fiber.type) {\n    case DOMType.TEXT:\n      createTextInstance(fiber, parentInstance);\n      break;\n    case DOMType.ELEMENT:\n      createInstance(fiber, parentInstance);\n      break;\n    case DOMType.FRAGMENT:\n      createFragmentInstance(fiber, parentInstance);\n      break;\n    default:\n      throw new Error(`Unknown fiber type`);\n  }\n}\n\nfunction createTextInstance(fiber: TextFiber, parentInstance: Node) {\n  const { value } = fiber;\n  const domTextNode = document.createTextNode(value);\n  fiber.domElement = domTextNode;\n\n  parentInstance.appendChild(domTextNode);\n}\n\nfunction createFragmentInstance(fiber: FragmentFiber, parentInstance: Node) {\n  const { children } = fiber;\n  fiber.domElement = parentInstance;\n\n  children.forEach((child) => {\n    mountHostComponent(child, parentInstance);\n  });\n}\n\nfunction createInstance(fiber: ElementFiber, parentInstance: Node) {\n  const { tag, props, children } = fiber;\n\n  const domElement = document.createElement(tag);\n  setInitialProperties(domElement, props, fiber);\n  fiber.domElement = domElement;\n\n  children.forEach((child) => {\n    mountHostComponent(child, domElement);\n  });\n  parentInstance.appendChild(domElement);\n}\n\nfunction setInitialProperties(\n  domElement: HTMLElement,\n  props: Props,\n  fiber: ElementFiber\n) {\n  const { on: events, ...attrs } = props;\n\n  if (events) {\n    fiber.listeners = attachEventListeners(events, domElement);\n  }\n  setProp(domElement, attrs);\n}\n\nexport { mountHostComponent };\n","import { destroyDOM } from \"./destroy-dom\";\nimport { Dispatcher } from \"./dispatcher\";\nimport { mountHostComponent } from \"./mount-host-component\";\nimport { Fiber } from \"./types\";\n\nfunction createApp({ state, view, reducers = {} }) {\n  let parentInstance: Node | null = null;\n  let fiber: Fiber | null = null;\n\n  const dispatcher = new Dispatcher();\n  const subscriptions = [dispatcher.afterEveryCommand(renderApp)];\n\n  function emit(eventType: string, payload: object = {}) {\n    dispatcher.dispatch(eventType, payload);\n  }\n\n  for (const actionName in reducers) {\n    const reducer = reducers[actionName];\n\n    const subs = dispatcher.subscribe(actionName, (payload) => {\n      state = reducer(state, payload);\n    });\n    subscriptions.push(subs);\n  }\n\n  function renderApp() {\n    if (fiber) {\n      destroyDOM(fiber);\n    }\n\n    fiber = view(state, emit);\n    if (fiber && parentInstance) {\n      mountHostComponent(fiber, parentInstance);\n    }\n  }\n\n  return {\n    mount(_parentInstance) {\n      parentInstance = _parentInstance;\n      renderApp();\n    },\n    unmount() {\n      if (fiber) {\n        destroyDOM(fiber);\n      }\n      fiber = null;\n      subscriptions.forEach((unsubscribe) => unsubscribe());\n    },\n  };\n}\n\nexport { createApp };\n","export function withoutNulls<T>(children: (T | null | undefined)[]): T[] {\n  return children.filter((child) => child != null);\n}\n","import {\n  DOMType,\n  ElementFiber,\n  Fiber,\n  FiberChild,\n  FragmentFiber,\n  Props,\n  TextFiber,\n} from \"./types\";\nimport { withoutNulls } from \"./utils/arrays\";\n\nfunction createElement(\n  tag: string,\n  props: Props = {},\n  children: FiberChild[] = []\n): ElementFiber {\n  return {\n    type: DOMType.ELEMENT,\n    tag,\n    props,\n    children: mapTextNodes(withoutNulls(children)),\n  };\n}\n\nfunction mapTextNodes(children: FiberChild[]): Fiber[] {\n  return children.map((child) =>\n    typeof child === \"string\" ? createTextElement(child) : child\n  );\n}\n\nfunction createTextElement(text: string): TextFiber {\n  return {\n    type: DOMType.TEXT,\n    value: text,\n  };\n}\n\nfunction createFragment(children: FiberChild[]): FragmentFiber {\n  return {\n    type: DOMType.FRAGMENT,\n    children: mapTextNodes(withoutNulls(children)),\n  };\n}\n\nexport { type DOMType, createElement };\n"],"names":["DOMType","destroyDOM","fiber","type","TEXT","domElement","remove","removeTextNode","ELEMENT","children","listeners","forEach","Object","entries","eventType","handler","removeEventListener","removeEventListeners","removeElementNode","FRAGMENT","removeFragmentNodes","Error","Dispatcher","subs","Map","afterHandlers","subscribe","commandName","this","has","set","handlers","get","includes","push","index","indexOf","splice","afterEveryCommand","dispatch","payload","console","warn","setProp","attrs","class","className","style","restAttrs","Array","isArray","classList","add","setClass","key","value","setStyle","setValueForAttribute","removeAttribute","removeValueForAttribute","startsWith","setAttribute","mountHostComponent","parentInstance","undefined","domTextNode","document","createTextNode","appendChild","createTextInstance","tag","props","createElement","on","events","attachedListeners","listener","addEventListener","attachEventListener","attachEventListeners","setInitialProperties","child","createInstance","createFragmentInstance","createApp","state","view","reducers","dispatcher","subscriptions","renderApp","emit","actionName","reducer","mount","_parentInstance","unmount","unsubscribe","withoutNulls","filter","mapTextNodes","map","text"],"mappings":"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"}