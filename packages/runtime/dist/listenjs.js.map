{"version":3,"file":"listenjs.js","sources":["../src/types.ts","../src/utils/arrays.ts","../src/create-element.ts","../src/events.ts","../src/scheduler.ts","../src/destroy-dom.ts","../src/set-prop.ts","../src/utils/props.ts","../src/mount-dom.ts","../src/create-app.ts","../src/dispatcher.ts","../src/utils/objects.ts","../src/utils/strings.ts","../src/vnode-equal.ts","../src/patch-dom.ts","../src/fiber.ts"],"sourcesContent":["import type { ActionName, ActionPayload } from \"./dispatcher\";\nimport type { DOMEventListener } from \"./events\";\nimport type { ClassComponent, ComponentInstance } from \"./fiber\";\n\nenum VDOMType {\n  TEXT = Node.TEXT_NODE,\n  ELEMENT = Node.ELEMENT_NODE,\n  FRAGMENT = Node.DOCUMENT_FRAGMENT_NODE,\n  COMPONENT = \"COMPONENT\",\n}\n\nenum ARRAY_DIFF_OP {\n  ADD = \"add\",\n  REMOVE = \"remove\",\n  MOVE = \"move\",\n  NOOP = \"noop\",\n}\n\ninterface Attributes {\n  [key: string]: unknown; // For general string attributes like id, title, href, etc.\n}\n\ntype DOMEventName = keyof GlobalEventHandlersEventMap;\n/**\n * DOM Event\n * @returns Emit\n */\ntype DOMEmitGenerator = (event?: Event) => Emit;\ntype DomEventMap = Partial<Record<DOMEventName, DOMEmitGenerator>>;\n\ntype FiberEventName = string;\n/**\n * Fiber Event\n * @returns Emit\n */\ntype FiberEmitGenerator = (actionPayload?: ActionPayload) => Emit;\ntype FiberEventMap = Record<FiberEventName, FiberEmitGenerator>;\n\ntype DOMProps = Attributes & {\n  on?: DomEventMap;\n  class?: string | string[]; // CSS classes\n  style?: Record<string, string>; // Inline styles\n};\n\ntype FiberProps = Attributes & {\n  on?: FiberEventMap;\n};\n\n// Virtual DOM node types\ninterface TextVNode {\n  type: VDOMType.TEXT;\n  value: string;\n  domElement?: Text;\n}\n\ninterface BaseNode {\n  children: ReactElement[];\n  listeners?: DOMEventListener;\n}\n\ninterface FiberVNode extends BaseNode {\n  props: FiberProps;\n  type: VDOMType.COMPONENT;\n  tag: ClassComponent;\n  fiberInstance: ComponentInstance;\n  domElement?: Text | HTMLElement;\n}\n\ninterface ElementVNode extends BaseNode {\n  props: DOMProps;\n  type: VDOMType.ELEMENT;\n  tag: string;\n  domElement?: HTMLElement;\n}\n\ninterface FragmentVNode {\n  type: VDOMType.FRAGMENT;\n  children: ReactElement[];\n  domElement?: HTMLElement;\n}\n\ntype ReactElement = TextVNode | ElementVNode | FiberVNode | FragmentVNode;\ntype VNodeChild = string | ReactElement; // Acceptable child types\ntype DomElement = Text | HTMLElement;\n\ntype State = Record<string, string | number | object>;\ntype View = (state: State, emit: Emit) => ReactElement;\n\ntype Reducer = (state: State, actionPayload?: ActionPayload) => State;\ntype Reducers = Record<ActionName, Reducer>;\n\ntype Emit = (actionName: ActionName, actionPayload?: ActionPayload) => void;\n\nexport {\n  VDOMType,\n  ARRAY_DIFF_OP,\n  type ElementVNode,\n  type FiberVNode,\n  type ReactElement,\n  type VNodeChild,\n  type FragmentVNode,\n  type Attributes,\n  type FiberEventMap,\n  type FiberEventName,\n  type FiberEmitGenerator,\n  type FiberProps,\n  type DOMProps,\n  type TextVNode,\n  type DomElement,\n  type DomEventMap,\n  type DOMEventName,\n  type DOMEmitGenerator,\n  type View,\n  type Reducers,\n};\n","import { ARRAY_DIFF_OP } from \"../types\";\n\nfunction withoutNulls<T>(children: (T | null | undefined)[]): T[] {\n  return children.filter((child) => child != null);\n}\n\nfunction arraysDiff<T>(\n  oldArray: T[],\n  newArray: T[]\n): {\n  added: T[];\n  removed: T[];\n} {\n  return {\n    added: newArray.filter((newArrayItem) => !oldArray.includes(newArrayItem)),\n    removed: oldArray.filter(\n      (oldArrayItem) => !newArray.includes(oldArrayItem)\n    ),\n  };\n}\n\ninterface Operation<T> {\n  op: ARRAY_DIFF_OP;\n  index: number;\n  item: T;\n}\n\ninterface NoopOperation<T> extends Operation<T> {\n  originalIndex: number;\n}\n\ninterface MoveOperation<T> extends Operation<T> {\n  originalIndex: number;\n  from: number;\n}\n\nclass ArrayWithOriginalIndices<T> {\n  #array: T[] = [];\n  #originalIndices: number[] = [];\n  #equalsFn: (a: T, b: T) => boolean;\n\n  constructor(array: T[], equalsFn: (a: T, b: T) => boolean) {\n    this.#array = [...array];\n    this.#originalIndices = array.map((_, index) => index);\n    this.#equalsFn = equalsFn;\n  }\n\n  get length() {\n    return this.#array.length;\n  }\n\n  originalIndexAt(index: number) {\n    return this.#originalIndices[index];\n  }\n\n  findIndexFrom(item: T, fromIndex: number) {\n    for (let index = fromIndex; index < this.length; index++) {\n      if (this.#equalsFn(item, this.#array[index])) {\n        return index;\n      }\n    }\n\n    return -1;\n  }\n\n  wasElementRemoved(index: number, newArray: T[]) {\n    if (index >= this.length) {\n      return false;\n    }\n\n    const item = this.#array[index];\n    const indexInNewArray = newArray.findIndex((newItem) =>\n      this.#equalsFn(item, newItem)\n    );\n\n    return indexInNewArray === -1;\n  }\n\n  wasElementTheSame(index: number, newArray: T[]) {\n    if (index >= this.length) {\n      return false;\n    }\n\n    const item = this.#array[index];\n    const newItem = newArray[index];\n\n    return this.#equalsFn(item, newItem);\n  }\n\n  wasElementAdded(item: T, fromIndex: number) {\n    return this.findIndexFrom(item, fromIndex) === -1;\n  }\n\n  removeItemAction(index: number): Operation<T> {\n    const operation: Operation<T> = {\n      op: ARRAY_DIFF_OP.REMOVE,\n      index,\n      item: this.#array[index],\n    };\n\n    this.#array.splice(index, 1);\n    this.#originalIndices.splice(index, 1);\n\n    return operation;\n  }\n\n  noopItemAction(index: number): NoopOperation<T> {\n    return {\n      op: ARRAY_DIFF_OP.NOOP,\n      originalIndex: this.originalIndexAt(index),\n      index,\n      item: this.#array[index],\n    };\n  }\n\n  addItemAction(item: T, index: number): Operation<T> {\n    const operation: Operation<T> = {\n      op: ARRAY_DIFF_OP.ADD,\n      index,\n      item,\n    };\n\n    this.#array.splice(index, 0, item);\n    this.#originalIndices.splice(index, 0, -1);\n\n    return operation;\n  }\n\n  moveItemAction(item: T, toIndex: number): MoveOperation<T> {\n    const fromIndex = this.findIndexFrom(item, toIndex);\n\n    const operation: MoveOperation<T> = {\n      op: ARRAY_DIFF_OP.MOVE,\n      originalIndex: this.originalIndexAt(fromIndex),\n      from: fromIndex,\n      index: toIndex,\n      item: this.#array[fromIndex],\n    };\n\n    const [_item] = this.#array.splice(fromIndex, 1);\n    this.#array.splice(toIndex, 0, _item);\n\n    const [originalIndex] = this.#originalIndices.splice(fromIndex, 1);\n    this.#originalIndices.splice(toIndex, 0, originalIndex);\n\n    return operation;\n  }\n\n  removeRestItems(index: number): Operation<T>[] {\n    const operations: Operation<T>[] = [];\n\n    while (this.length > index) {\n      operations.push(this.removeItemAction(index));\n    }\n\n    return operations;\n  }\n}\n\nfunction arraysDiffSequence<T>(\n  oldArray: T[],\n  newArray: T[],\n  equalsFn: (a: T, b: T) => boolean = (a, b) => a === b\n): Array<Operation<T> | NoopOperation<T> | MoveOperation<T>> {\n  const sequence: Array<Operation<T> | NoopOperation<T> | MoveOperation<T>> =\n    [];\n  const array = new ArrayWithOriginalIndices<T>(oldArray, equalsFn);\n\n  for (let index = 0; index < newArray.length; index++) {\n    if (array.wasElementRemoved(index, newArray)) {\n      sequence.push(array.removeItemAction(index));\n      index--;\n      continue;\n    }\n\n    if (array.wasElementTheSame(index, newArray)) {\n      sequence.push(array.noopItemAction(index));\n      continue;\n    }\n\n    const item = newArray[index];\n\n    if (array.wasElementAdded(item, index)) {\n      sequence.push(array.addItemAction(item, index));\n      continue;\n    }\n\n    sequence.push(array.moveItemAction(item, index));\n  }\n\n  sequence.push(...array.removeRestItems(newArray.length));\n\n  return sequence;\n}\n\nexport { withoutNulls, arraysDiff, arraysDiffSequence };\n","import { VDOMType } from \"./types\";\nimport { withoutNulls } from \"./utils/arrays\";\n\nimport type { ClassComponent } from \"./fiber\";\nimport type {\n  ElementVNode,\n  ReactElement,\n  VNodeChild,\n  TextVNode,\n  FiberVNode,\n  DOMProps,\n  FiberProps,\n} from \"./types\";\n\nfunction createElement(\n  tag: string | ClassComponent,\n  props: DOMProps | FiberProps = {},\n  children: VNodeChild[] = []\n): ElementVNode | FiberVNode {\n  if (typeof tag === \"string\") {\n    return {\n      type: VDOMType.ELEMENT,\n      tag,\n      props,\n      children: mapTextNodes(withoutNulls(children)),\n    } as ElementVNode;\n  } else {\n    return {\n      type: VDOMType.COMPONENT,\n      tag,\n      props,\n      children: mapTextNodes(withoutNulls(children)),\n    } as FiberVNode;\n  }\n}\n\nfunction mapTextNodes(children: VNodeChild[]): ReactElement[] {\n  return children.map((child) =>\n    typeof child === \"string\" ? createTextElement(child) : child\n  );\n}\n\nfunction createTextElement(text: string): TextVNode {\n  return {\n    type: VDOMType.TEXT as const,\n    value: text,\n  };\n}\n\nexport { createElement };\n","import type { ComponentInstance } from \"./fiber\";\nimport type { DomEventMap, DOMEventName, DOMEmitGenerator } from \"./types\";\n\ntype DOMEventWithContext = (event: Event) => void;\ntype DOMEventListener = Partial<Record<DOMEventName, DOMEventWithContext>>;\n\nfunction attachEventListener(\n  domEventName: DOMEventName,\n  emitGenerator: DOMEmitGenerator,\n  domElement: HTMLElement,\n  parentFiberInstance: ComponentInstance | null = null\n) {\n  function boundContextToDOMEvent(...args: [Event]) {\n    if (parentFiberInstance) {\n      emitGenerator.apply(parentFiberInstance, args);\n    } else {\n      emitGenerator(...args);\n    }\n  }\n\n  domElement.addEventListener(domEventName, boundContextToDOMEvent);\n\n  return boundContextToDOMEvent;\n}\n\nfunction attachEventListeners(\n  domEventMap: DomEventMap = {},\n  domElement: HTMLElement,\n  parentFiberInstance: ComponentInstance | null = null\n): DOMEventListener {\n  const attachedDOMEventListeners: DOMEventListener = {};\n\n  Object.entries(domEventMap).forEach(([domEventName, emitGenerator]) => {\n    const listener = attachEventListener(\n      domEventName as DOMEventName,\n      emitGenerator,\n      domElement,\n      parentFiberInstance\n    );\n    attachedDOMEventListeners[domEventName] = listener;\n  });\n\n  return attachedDOMEventListeners;\n}\n\nfunction removeEventListeners(\n  attachedDOMEventListeners: DOMEventListener = {},\n  domElement: HTMLElement\n) {\n  Object.entries(attachedDOMEventListeners).forEach(\n    ([domEventName, domEventWithContext]) => {\n      domElement.removeEventListener(domEventName, domEventWithContext);\n    }\n  );\n}\n\nexport {\n  attachEventListener,\n  attachEventListeners,\n  removeEventListeners,\n  type DOMEventListener,\n};\n","let isScheduled = false;\nconst jobs: Array<() => Promise<VoidFunction>> = [];\n\nfunction enqueueJob(job: () => Promise<VoidFunction>) {\n  jobs.push(job);\n  scheduleUpdate();\n}\n\nfunction scheduleUpdate() {\n  if (isScheduled) {\n    return;\n  }\n\n  isScheduled = true;\n  queueMicrotask(processJobs);\n}\n\nfunction processJobs() {\n  while (jobs.length > 0) {\n    const job = jobs.shift();\n    if (!job) {\n      return;\n    }\n\n    const result = job();\n\n    Promise.resolve(result).then(\n      () => {\n        // success\n      },\n      (error) => {\n        console.error(`[scheduler]: ${error}`);\n      }\n    );\n  }\n\n  isScheduled = false;\n}\n\nfunction flushPromises() {\n  return new Promise((resolve) => setTimeout(resolve));\n}\n\nfunction nextTick() {\n  scheduleUpdate();\n  return flushPromises();\n}\n\nexport { enqueueJob, nextTick };\n","import { removeEventListeners } from \"./events\";\nimport { enqueueJob } from \"./scheduler\";\nimport { VDOMType } from \"./types\";\n\nimport type {\n  ElementVNode,\n  FragmentVNode,\n  TextVNode,\n  ReactElement,\n} from \"./types\";\n\nfunction destroyDOM(vNode: ReactElement) {\n  const { type } = vNode;\n\n  switch (type) {\n    case VDOMType.TEXT: {\n      removeTextNode(vNode);\n      break;\n    }\n    case VDOMType.ELEMENT: {\n      removeElementNode(vNode);\n      break;\n    }\n    case VDOMType.FRAGMENT: {\n      removeFragmentNodes(vNode);\n      break;\n    }\n    case VDOMType.COMPONENT: {\n      vNode.fiberInstance.unmount();\n      enqueueJob(() => vNode.fiberInstance.componentWillUnmount());\n      break;\n    }\n\n    default: {\n      throw new Error(\"Cannot destroy DOM of type: \", type);\n    }\n  }\n\n  delete vNode.domElement;\n}\n\nfunction removeTextNode(vNode: TextVNode) {\n  const { domElement } = vNode;\n  if (domElement) {\n    domElement.remove();\n  }\n}\n\nfunction removeElementNode(vNode: ElementVNode) {\n  const { domElement, children, listeners } = vNode;\n\n  if (!domElement) {\n    return;\n  }\n\n  domElement.remove();\n  children.forEach(destroyDOM);\n\n  if (listeners) {\n    removeEventListeners(listeners, domElement);\n    delete vNode.listeners;\n  }\n}\n\nfunction removeFragmentNodes(vNode: FragmentVNode) {\n  const { children } = vNode;\n  children.forEach(destroyDOM);\n}\n\nexport { destroyDOM };\n","import type { DOMProps, FiberProps } from \"./types\";\n\nfunction setProp(domElement: HTMLElement, props: DOMProps | FiberProps) {\n  const { class: className, style, ...restAttrs } = props;\n\n  if (typeof className === \"string\" || Array.isArray(className)) {\n    setClass(domElement, className);\n  }\n\n  if (style) {\n    Object.entries(style).forEach(([key, value]) => {\n      if (typeof value === \"string\") {\n        setStyle(domElement, key, value);\n      }\n    });\n  }\n\n  for (const [key, value] of Object.entries(restAttrs)) {\n    if (typeof value === \"string\") {\n      setValueForAttribute(domElement, key, value);\n    }\n  }\n}\n\nfunction setClass(domElement: HTMLElement, className: string | string[]) {\n  domElement.className = \"\";\n\n  if (typeof className === \"string\") {\n    domElement.className = className;\n  }\n\n  if (Array.isArray(className)) {\n    domElement.classList.add(...className);\n  }\n}\n\nfunction setStyle(domElement: HTMLElement, key: string, value: string) {\n  domElement.style[key] = value;\n}\n\nfunction removeStyle(domElement: HTMLElement, key: string) {\n  domElement.style[key] = null;\n}\n\nfunction setValueForAttribute(\n  domElement: HTMLElement,\n  key: string,\n  value: unknown\n) {\n  if (value == null) {\n    removeValueForAttribute(domElement, key);\n  } else if (key.startsWith(\"data-\")) {\n    domElement.setAttribute(key, String(value));\n  } else {\n    domElement[key] = value;\n  }\n}\n\nfunction removeValueForAttribute(domElement: HTMLElement, key: string) {\n  domElement[key] = null;\n  domElement.removeAttribute(key);\n}\n\nexport {\n  setProp,\n  setValueForAttribute,\n  removeValueForAttribute,\n  setStyle,\n  removeStyle,\n};\n","import type { ElementVNode, FiberVNode } from \"../types\";\n\nfunction extractPropsAndEvents<T extends FiberVNode | ElementVNode>(vNode: T) {\n  const { on: eventMap, ...props } = vNode.props;\n  delete props.key;\n\n  return { props, eventMap };\n}\n\nexport { extractPropsAndEvents };\n","import { attachEventListeners } from \"./events\";\nimport { enqueueJob } from \"./scheduler\";\nimport { setProp } from \"./set-prop\";\nimport { VDOMType } from \"./types\";\nimport { extractPropsAndEvents } from \"./utils/props\";\n\nimport type { ComponentInstance } from \"./fiber\";\nimport type {\n  DomElement,\n  ElementVNode,\n  FragmentVNode,\n  TextVNode,\n  ReactElement,\n  FiberVNode,\n  FiberEventMap,\n} from \"./types\";\n\nfunction mountDOM(\n  vNode: ReactElement,\n  parentDOMElement: HTMLElement,\n  positionIndex: number | null = null,\n  parentFiberInstance: ComponentInstance | null = null\n) {\n  if (parentDOMElement == undefined) {\n    throw new Error(`\n      \"Parent element is not defined: ${parentDOMElement}`);\n  }\n\n  switch (vNode.type) {\n    case VDOMType.TEXT:\n      createDOMElementFromTextNode(vNode, parentDOMElement, positionIndex);\n      break;\n    case VDOMType.ELEMENT:\n      createDOMElementFromElementNode(\n        vNode,\n        parentDOMElement,\n        positionIndex,\n        parentFiberInstance\n      );\n      break;\n    case VDOMType.FRAGMENT:\n      createDOMElementFromFragmentNode(\n        vNode,\n        parentDOMElement,\n        positionIndex,\n        parentFiberInstance\n      );\n      break;\n    case VDOMType.COMPONENT:\n      createDOMElementFromFiberNode(\n        vNode,\n        parentDOMElement,\n        positionIndex,\n        parentFiberInstance\n      );\n      enqueueJob(() => vNode.fiberInstance.componentDidMount());\n      break;\n    default:\n      throw new Error(`Unknown vNode type`);\n  }\n}\n\nfunction createDOMElementFromTextNode(\n  vNode: TextVNode,\n  parentDOMElement: HTMLElement,\n  positionIndex: number | null\n) {\n  const { value } = vNode;\n  const domTextNode = document.createTextNode(value);\n  vNode.domElement = domTextNode;\n\n  insertIntoDOM(domTextNode, parentDOMElement, positionIndex);\n}\n\nfunction createDOMElementFromFragmentNode(\n  vNode: FragmentVNode,\n  parentDOMElement: HTMLElement,\n  positionIndex: number | null,\n  parentFiberInstance: ComponentInstance | null = null\n) {\n  const { children } = vNode;\n  vNode.domElement = parentDOMElement;\n\n  children.forEach((child, index) => {\n    mountDOM(\n      child,\n      parentDOMElement,\n      positionIndex ? positionIndex + index : null,\n      parentFiberInstance\n    );\n  });\n}\n\nfunction createDOMElementFromElementNode(\n  vNode: ElementVNode,\n  parentDOMElement: HTMLElement,\n  positionIndex: number | null,\n  parentFiberInstance: ComponentInstance | null = null\n) {\n  const { tag, children } = vNode;\n\n  const domElement = document.createElement(tag);\n  setInitialProperties(domElement, vNode, parentFiberInstance);\n  vNode.domElement = domElement;\n\n  children.forEach((child) => {\n    mountDOM(child, domElement, null, parentFiberInstance);\n  });\n\n  return insertIntoDOM(domElement, parentDOMElement, positionIndex);\n}\n\nfunction createDOMElementFromFiberNode(\n  vNode: FiberVNode,\n  parentDOMElement: HTMLElement,\n  positionIndex: number | null,\n  parentFiberInstance: ComponentInstance | null = null\n) {\n  const ClassComponent = vNode.tag;\n  const { eventMap: fiberEventMap, props } = extractPropsAndEvents(vNode);\n  const fiberInstance = new ClassComponent(\n    props,\n    fiberEventMap as FiberEventMap,\n    parentFiberInstance\n  );\n\n  fiberInstance.mount(parentDOMElement, positionIndex);\n  vNode.fiberInstance = fiberInstance;\n  vNode.domElement = fiberInstance.firstDOMElement;\n}\n\nfunction setInitialProperties(\n  domElement: HTMLElement,\n  vNode: ElementVNode,\n  parentFiberInstance: ComponentInstance | null\n) {\n  const { eventMap, props } = extractPropsAndEvents(vNode);\n\n  if (eventMap) {\n    vNode.listeners = attachEventListeners(\n      eventMap,\n      domElement,\n      parentFiberInstance\n    );\n  }\n  setProp(domElement, props);\n}\n\nfunction insertIntoDOM(\n  domElement: DomElement,\n  parentDOMElement: Node,\n  positionIndex: number | null\n) {\n  if (positionIndex == null) {\n    return parentDOMElement.appendChild(domElement);\n  }\n\n  if (positionIndex < 0) {\n    throw new Error(\n      `Position Index must be positive integer, but got ${positionIndex}`\n    );\n  }\n\n  const children = parentDOMElement.childNodes;\n\n  if (positionIndex >= children.length) {\n    parentDOMElement.appendChild(domElement);\n  } else {\n    parentDOMElement.insertBefore(domElement, children[positionIndex]);\n  }\n}\n\nfunction extractChildren(vNode: ReactElement) {\n  if (\"children\" in vNode) {\n    const children: ReactElement[] = [];\n\n    for (const child of vNode.children) {\n      if (child.type === VDOMType.FRAGMENT) {\n        children.push(...extractChildren(child));\n      } else {\n        children.push(child);\n      }\n    }\n\n    return children;\n  }\n  return [];\n}\n\nexport { mountDOM, extractChildren };\n","import { createElement } from \"./create-element\";\nimport { destroyDOM } from \"./destroy-dom\";\nimport { mountDOM } from \"./mount-dom\";\n\nimport type { ClassComponent } from \"./fiber\";\nimport type { DOMProps, FiberProps, ReactElement } from \"./types\";\n\nfunction createApp(\n  RootComponent: string | ClassComponent,\n  props: DOMProps | FiberProps = {}\n) {\n  let parentDOMElement: HTMLElement | null;\n  let isMounted: boolean = false;\n  let rootVNode: ReactElement | null = null;\n\n  function reset() {\n    parentDOMElement = null;\n    isMounted = false;\n    rootVNode = null;\n  }\n\n  return {\n    mount(_parentDOMElement: HTMLElement) {\n      if (isMounted) {\n        throw new Error(\"App is already mounted\");\n      }\n\n      parentDOMElement = _parentDOMElement;\n      rootVNode = createElement(RootComponent, props);\n\n      if (parentDOMElement) {\n        mountDOM(rootVNode, parentDOMElement);\n      }\n      isMounted = true;\n    },\n\n    unmount() {\n      if (!isMounted) {\n        throw new Error(\"App is not even mounted\");\n      }\n\n      if (!rootVNode) {\n        throw new Error(\"There is not even root virtual node\");\n      }\n\n      destroyDOM(rootVNode);\n      reset();\n    },\n  };\n}\n\nexport { createApp };\n","type ActionName = string;\ntype ActionPayload = string | number | object;\ntype ReducerWithInjectedState = (payload?: ActionPayload) => void;\n\ntype AfterCommandHandler = () => void;\ntype UnsubscribeFunction = () => void;\n\nclass Dispatcher {\n  #actionSubscriptions: Map<string, ReducerWithInjectedState[]> = new Map();\n  #afterHandlers: AfterCommandHandler[] = [];\n\n  subscribe(\n    actionName: ActionName,\n    reducerWithInjectedState: ReducerWithInjectedState\n  ): UnsubscribeFunction {\n    if (!this.#actionSubscriptions.has(actionName)) {\n      this.#actionSubscriptions.set(actionName, []);\n    }\n\n    const reducers = this.#actionSubscriptions.get(actionName);\n    if (reducers?.includes(reducerWithInjectedState)) {\n      return () => {};\n    }\n    reducers?.push(reducerWithInjectedState);\n\n    return function unsubscribe() {\n      if (reducers) {\n        const index = reducers?.indexOf(reducerWithInjectedState);\n        reducers?.splice(index, 1);\n      }\n    };\n  }\n\n  afterEveryCommand(afterHandler: AfterCommandHandler) {\n    this.#afterHandlers.push(afterHandler);\n    return () => {\n      const index = this.#afterHandlers.indexOf(afterHandler);\n      this.#afterHandlers.splice(index, 1);\n    };\n  }\n\n  dispatch(actionName: ActionName, actionPayload?: ActionPayload) {\n    if (this.#actionSubscriptions.has(actionName)) {\n      this.#actionSubscriptions\n        .get(actionName)\n        ?.forEach((reducer) => reducer(actionPayload));\n    } else {\n      console.warn(`No handlers found for command: ${actionName}`);\n    }\n\n    this.#afterHandlers.forEach((afterHandler) => afterHandler());\n  }\n}\n\nexport {\n  Dispatcher,\n  type ActionName,\n  type ActionPayload,\n  type UnsubscribeFunction,\n};\n","import type { DomEventMap, DOMEventName } from \"../types\";\n\nfunction objectsDiff(\n  oldObject: DomEventMap,\n  newObject: DomEventMap\n): {\n  added: DOMEventName[];\n  removed: DOMEventName[];\n  updated: DOMEventName[];\n} {\n  const oldKeys = Object.keys(oldObject) as DOMEventName[];\n  const newKeys = Object.keys(newObject) as DOMEventName[];\n\n  return {\n    added: newKeys.filter((newKey) => !(newKey in oldObject)),\n    removed: oldKeys.filter((oldKey) => !(oldKey in newObject)),\n    updated: newKeys.filter(\n      (newKey) => newKey in oldObject && oldObject[newKey] !== newObject[newKey]\n    ),\n  };\n}\n\nfunction hasOwnProperty(obj: object, prop: string) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexport { objectsDiff, hasOwnProperty };\n","function isNotEmptyString(str: string) {\n  return str !== \"\";\n}\n\nfunction isNotBlankOrEmptyString(str: string) {\n  return isNotEmptyString(str.trim());\n}\n\nexport { isNotBlankOrEmptyString };\n","import { VDOMType } from \"./types\";\n\nimport type { ReactElement } from \"./types\";\n\nfunction areVNodesEqual(vNodeA: ReactElement, vNodeB: ReactElement) {\n  if (\n    vNodeA.type === vNodeB.type &&\n    vNodeA.type === VDOMType.ELEMENT &&\n    vNodeB.type === VDOMType.ELEMENT\n  ) {\n    const {\n      tag: tagA,\n      props: { key: keyA },\n    } = vNodeA;\n    const {\n      tag: tagB,\n      props: { key: keyB },\n    } = vNodeB;\n\n    return tagA === tagB && keyA === keyB;\n  }\n\n  if (\n    vNodeA.type === vNodeB.type &&\n    vNodeA.type === VDOMType.COMPONENT &&\n    vNodeB.type === VDOMType.COMPONENT\n  ) {\n    const {\n      tag: tagA,\n      props: { key: keyA },\n    } = vNodeA;\n    const {\n      tag: tagB,\n      props: { key: keyB },\n    } = vNodeB;\n\n    return tagA === tagB && keyA === keyB;\n  }\n\n  return false;\n}\n\nexport { areVNodesEqual };\n","import { destroyDOM } from \"./destroy-dom\";\nimport { attachEventListener } from \"./events\";\nimport { extractChildren, mountDOM } from \"./mount-dom\";\nimport {\n  removeStyle,\n  removeValueForAttribute,\n  setStyle,\n  setValueForAttribute,\n} from \"./set-prop\";\nimport { ARRAY_DIFF_OP, VDOMType } from \"./types\";\nimport { arraysDiff, arraysDiffSequence } from \"./utils/arrays\";\nimport { objectsDiff } from \"./utils/objects\";\nimport { extractPropsAndEvents } from \"./utils/props\";\nimport { isNotBlankOrEmptyString } from \"./utils/strings\";\nimport { areVNodesEqual } from \"./vnode-equal\";\n\nimport type { ComponentInstance } from \"./fiber\";\nimport type {\n  Attributes,\n  DomElement,\n  ElementVNode,\n  TextVNode,\n  ReactElement,\n  FiberVNode,\n  DOMProps,\n} from \"./types\";\n\nfunction patchDOM(\n  oldVNode: ReactElement,\n  newVNode: ReactElement,\n  parentDOMNode: HTMLElement,\n  parentFiberInstance: ComponentInstance | null = null\n) {\n  if (!areVNodesEqual(oldVNode, newVNode)) {\n    const positionIndex = oldVNode.domElement\n      ? findIndexInParent(parentDOMNode, oldVNode.domElement)\n      : undefined;\n\n    destroyDOM(oldVNode);\n    mountDOM(newVNode, parentDOMNode, positionIndex, parentFiberInstance);\n\n    return newVNode;\n  }\n\n  newVNode.domElement = oldVNode.domElement;\n\n  switch (newVNode.type) {\n    case VDOMType.TEXT: {\n      if (oldVNode.type === VDOMType.TEXT) {\n        patchText(oldVNode, newVNode);\n      }\n\n      return newVNode;\n    }\n\n    case VDOMType.ELEMENT: {\n      if (oldVNode.type === VDOMType.ELEMENT) {\n        patchElement(oldVNode, newVNode, parentFiberInstance);\n      }\n      break;\n    }\n\n    case VDOMType.COMPONENT: {\n      if (oldVNode.type === VDOMType.COMPONENT) {\n        patchFiber(oldVNode, newVNode);\n      }\n      break;\n    }\n  }\n\n  patchChildren(oldVNode, newVNode, parentFiberInstance);\n\n  return newVNode;\n}\n\nfunction findIndexInParent(\n  parentDOMNode: Node,\n  domElement: DomElement\n): number | null {\n  const positionIndex = Array.from(parentDOMNode.childNodes).indexOf(\n    domElement\n  );\n\n  if (positionIndex < 0) {\n    return null;\n  }\n\n  return positionIndex;\n}\n\nfunction patchText(oldVNode: TextVNode, newVNode: TextVNode) {\n  if (!oldVNode.domElement) {\n    throw new Error(`Cannot find DOM Element for old vNode: ${oldVNode}`);\n  }\n\n  const domElement: Text = oldVNode.domElement;\n  const { value: oldText } = oldVNode;\n  const { value: newText } = newVNode;\n\n  if (oldText !== newText) {\n    domElement.nodeValue = newText;\n  }\n}\n\nfunction patchElement(\n  oldVNode: ElementVNode,\n  newVNode: ElementVNode,\n  parentFiber: ComponentInstance | null = null\n) {\n  if (!oldVNode.domElement) {\n    throw new Error(`Cannot find DOM Element for old vNode: ${oldVNode}`);\n  }\n\n  if (!(oldVNode.domElement instanceof HTMLElement)) {\n    throw new Error(\"patchElement was called with a non-HTMLElement.\");\n  }\n\n  const domElement: HTMLElement = oldVNode.domElement;\n  const {\n    class: oldClass,\n    style: oldStyle,\n    on: oldOnEvents,\n    ...oldRestAttributes\n  } = oldVNode.props;\n  const {\n    class: newClass,\n    style: newStyle,\n    on: newOnEvents,\n    ...newRestAttributes\n  } = newVNode.props;\n  const { listeners: oldListeners } = oldVNode;\n\n  patchAttributes(domElement, oldRestAttributes, newRestAttributes);\n  patchClasses(domElement, oldClass, newClass);\n  patchStyles(domElement, oldStyle, newStyle);\n  newVNode.listeners = patchEvents(\n    domElement,\n    oldListeners,\n    oldOnEvents,\n    newOnEvents,\n    parentFiber\n  );\n\n  function patchAttributes(\n    domElement: HTMLElement,\n    oldRestAttributes: Attributes,\n    newRestAttributes: Attributes\n  ) {\n    const { added, removed, updated } = objectsDiff(\n      oldRestAttributes,\n      newRestAttributes\n    );\n\n    for (const key of removed) {\n      removeValueForAttribute(domElement, key);\n    }\n\n    for (const key of added.concat(updated)) {\n      setValueForAttribute(domElement, key, newRestAttributes[key]);\n    }\n  }\n\n  function patchClasses(\n    domElement: HTMLElement,\n    oldClass: DOMProps[\"class\"],\n    newClass: DOMProps[\"class\"]\n  ) {\n    const oldClasses = toClassList(oldClass);\n    const newClasses = toClassList(newClass);\n\n    const { added, removed } = arraysDiff(oldClasses, newClasses);\n\n    if (removed.length > 0) {\n      domElement.classList.remove(...removed);\n    }\n    if (added.length > 0) {\n      domElement.classList.add(...added);\n    }\n\n    function toClassList(classes: DOMProps[\"class\"] = \"\") {\n      return Array.isArray(classes)\n        ? classes.filter(isNotBlankOrEmptyString)\n        : classes.split(/(\\s+)/).filter(isNotBlankOrEmptyString);\n    }\n  }\n\n  function patchStyles(\n    domElement: HTMLElement,\n    oldStyle: DOMProps[\"style\"] = {},\n    newStyle: DOMProps[\"style\"] = {}\n  ) {\n    const { added, removed, updated } = objectsDiff(oldStyle, newStyle);\n\n    for (const key of removed) {\n      removeStyle(domElement, key);\n    }\n\n    for (const key of added.concat(updated)) {\n      setStyle(domElement, key, newStyle[key]);\n    }\n  }\n\n  function patchEvents(\n    domElement: HTMLElement,\n    oldListeners: ElementVNode[\"listeners\"] = {},\n    oldOnEvents: DOMProps[\"on\"] = {},\n    newOnEvents: DOMProps[\"on\"] = {},\n    parentFiber: ComponentInstance | null = null\n  ) {\n    const { added, removed, updated } = objectsDiff(oldOnEvents, newOnEvents);\n\n    for (const domEventName of removed.concat(updated)) {\n      if (oldListeners[domEventName]) {\n        domElement.removeEventListener(\n          domEventName,\n          oldListeners[domEventName]\n        );\n      }\n    }\n\n    const addedListeners: ElementVNode[\"listeners\"] = {};\n\n    for (const eventType of added.concat(updated)) {\n      if (newOnEvents[eventType]) {\n        addedListeners[eventType] = attachEventListener(\n          eventType,\n          newOnEvents[eventType],\n          domElement,\n          parentFiber\n        );\n      }\n    }\n\n    return addedListeners;\n  }\n}\n\nfunction patchFiber(oldVNode: FiberVNode, newVNode: FiberVNode) {\n  const { fiberInstance: oldFiberInstance } = oldVNode;\n  const { props: newProps } = extractPropsAndEvents(newVNode);\n\n  oldFiberInstance.updateProps(newProps);\n\n  newVNode.fiberInstance = oldFiberInstance;\n  newVNode.domElement = oldFiberInstance.firstDOMElement;\n}\n\nfunction patchChildren(\n  oldVNode: ReactElement,\n  newVNode: ReactElement,\n  parentFiber: ComponentInstance | null = null\n) {\n  if (!oldVNode.domElement) {\n    throw new Error(`Cannot find DOM Element for old vNode: ${oldVNode}`);\n  }\n\n  const oldChildren = extractChildren(oldVNode);\n  const newChildren = extractChildren(newVNode);\n  const parentDomElement = oldVNode.domElement;\n\n  const diffSequence = arraysDiffSequence<ReactElement>(\n    oldChildren,\n    newChildren,\n    areVNodesEqual\n  );\n\n  for (const operation of diffSequence) {\n    const { index, item, op } = operation;\n    const offset = parentFiber?.offset ?? 0;\n\n    switch (op) {\n      case ARRAY_DIFF_OP.ADD: {\n        if (parentDomElement instanceof HTMLElement) {\n          mountDOM(item, parentDomElement, index + offset, parentFiber);\n        }\n        break;\n      }\n      case ARRAY_DIFF_OP.REMOVE: {\n        destroyDOM(item);\n        break;\n      }\n      case ARRAY_DIFF_OP.MOVE: {\n        if (parentDomElement instanceof HTMLElement) {\n          if (\"originalIndex\" in operation) {\n            const oldChild = oldChildren[operation.originalIndex + offset];\n            const newChild = newChildren[index];\n\n            if (!oldChild.domElement) {\n              throw new Error(\n                `Cannot find DOM Element for old vNode: ${oldVNode}`\n              );\n            }\n\n            const domElement = oldChild.domElement;\n            const domElementAtTargetPosition =\n              parentDomElement.childNodes[index];\n\n            parentDomElement.insertBefore(\n              domElement,\n              domElementAtTargetPosition\n            );\n            patchDOM(oldChild, newChild, parentDomElement, parentFiber);\n          }\n        }\n        break;\n      }\n      case ARRAY_DIFF_OP.NOOP: {\n        if (parentDomElement instanceof HTMLElement) {\n          if (\"originalIndex\" in operation) {\n            patchDOM(\n              oldChildren[operation.originalIndex],\n              newChildren[index],\n              parentDomElement,\n              parentFiber\n            );\n          }\n        }\n        break;\n      }\n    }\n  }\n}\n\nexport { patchDOM };\n","import { destroyDOM } from \"./destroy-dom\";\nimport { Dispatcher } from \"./dispatcher\";\nimport { extractChildren, mountDOM } from \"./mount-dom\";\nimport { patchDOM } from \"./patch-dom\";\nimport { VDOMType } from \"./types\";\nimport { hasOwnProperty } from \"./utils/objects\";\n\nimport type { ActionPayload, UnsubscribeFunction } from \"./dispatcher\";\nimport type {\n  FiberEmitGenerator,\n  FiberEventMap,\n  FiberEventName,\n  FiberProps,\n  ReactElement,\n} from \"./types\";\n\nfunction voidFunction() {}\n\ntype FiberEventListener = Record<FiberEventName, FiberEmitGenerator>;\n\ntype RegularProps = Record<string, VoidFunction>;\ninterface CreateComponentProps extends RegularProps {\n  render: () => ReactElement;\n  state: (props?: object) => object;\n  componentDidMount: VoidFunction;\n  componentWillUnmount: VoidFunction;\n}\n\nfunction createComponent({\n  render,\n  state,\n  componentDidMount = voidFunction,\n  componentWillUnmount = voidFunction,\n  ...methods\n}: CreateComponentProps) {\n  class Fiber implements ComponentInstance {\n    #isMounted = false;\n    #vNode: ReactElement | null;\n    #domElement: HTMLElement | null;\n    #fiberListeners: FiberEventListener;\n    #parentFiberInstance: ComponentInstance | null;\n    #dispatcher = new Dispatcher();\n    #unSubscriptions: Array<UnsubscribeFunction>;\n\n    props: object;\n    state: object;\n\n    constructor(\n      props: FiberProps = {},\n      fiberEventMap: FiberEventMap = {},\n      parentFiberInstance: ComponentInstance | null = null\n    ) {\n      this.props = props;\n      this.state = state ? state(props) : {};\n      this.#fiberListeners = fiberEventMap;\n      this.#parentFiberInstance = parentFiberInstance;\n    }\n\n    get domElements() {\n      if (this.#vNode == null) {\n        return [];\n      }\n\n      if (this.#vNode.type === VDOMType.FRAGMENT) {\n        return extractChildren(this.#vNode).flatMap((child) => {\n          if (child.type === VDOMType.COMPONENT) {\n            return child.fiberInstance.domElements;\n          }\n          return child.domElement ? [child.domElement] : [];\n        });\n      }\n\n      return this.#vNode.domElement ? [this.#vNode.domElement] : [];\n    }\n\n    get firstDOMElement() {\n      return this.domElements[0];\n    }\n\n    get offset() {\n      if (\n        this.#domElement &&\n        this.firstDOMElement &&\n        this.#vNode?.type === VDOMType.FRAGMENT\n      ) {\n        return Array.from(this.#domElement?.childNodes).indexOf(\n          this.firstDOMElement\n        );\n      }\n\n      return 0;\n    }\n\n    render() {\n      return render.call(this);\n    }\n\n    emit(fiberEventName: FiberEventName, actionPayload?: ActionPayload) {\n      this.#dispatcher.dispatch(fiberEventName, actionPayload);\n    }\n\n    updateProps(props) {\n      this.props = { ...this.props, ...props };\n      this.#patch();\n    }\n\n    setState(state: object) {\n      this.state = { ...this.state, ...state };\n      this.#patch();\n    }\n\n    componentDidMount() {\n      return Promise.resolve<VoidFunction>(componentDidMount.call(this));\n    }\n\n    componentWillUnmount() {\n      return Promise.resolve<VoidFunction>(componentWillUnmount.call(this));\n    }\n\n    mount(hostDOMElement: HTMLElement, positionIndex: number | null = null) {\n      if (this.#isMounted) {\n        throw new Error(\"Fiber is already mounted\");\n      }\n\n      this.#vNode = this.render();\n      if (this.#vNode) {\n        mountDOM(this.#vNode, hostDOMElement, positionIndex, this);\n      }\n      this.#wireFiberEventListeners();\n\n      this.#domElement = hostDOMElement;\n      this.#isMounted = true;\n    }\n\n    unmount() {\n      if (!this.#isMounted) {\n        throw new Error(\"Fiber is not mounted\");\n      }\n\n      if (this.#vNode) {\n        destroyDOM(this.#vNode);\n      }\n      this.#unSubscriptions.forEach((unsubscribe) => unsubscribe());\n\n      this.#vNode = null;\n      this.#domElement = null;\n      this.#isMounted = false;\n      this.#unSubscriptions = [];\n    }\n\n    #patch() {\n      if (!this.#isMounted) {\n        throw new Error(\"Fiber is not mounted\");\n      }\n\n      const nextVNode = this.render();\n      if (this.#vNode && this.#domElement) {\n        this.#vNode = patchDOM(this.#vNode, nextVNode, this.#domElement, this);\n      }\n    }\n\n    #wireFiberEventListener(\n      fiberEventName: FiberEventName,\n      emitGenerator: FiberEmitGenerator\n    ) {\n      return this.#dispatcher.subscribe(fiberEventName, (payload) => {\n        if (this.#parentFiberInstance) {\n          emitGenerator.call(this.#parentFiberInstance, payload);\n        } else {\n          emitGenerator(payload);\n        }\n      });\n    }\n\n    #wireFiberEventListeners() {\n      this.#unSubscriptions = Object.entries(this.#fiberListeners).map(\n        ([fiberEventName, fiberEmitGenerator]) =>\n          this.#wireFiberEventListener(fiberEventName, fiberEmitGenerator)\n      );\n    }\n  }\n\n  for (const methodName in methods) {\n    if (hasOwnProperty(Fiber, methodName)) {\n      throw new Error(`Method ${methodName} already exists in the component.`);\n    }\n\n    Fiber.prototype[methodName] = methods[methodName];\n  }\n\n  return Fiber;\n}\n\ntype ClassComponent = ReturnType<typeof createComponent>;\ninterface ComponentInstance {\n  props: object;\n  state: object;\n  domElements: (HTMLElement | Text)[];\n  firstDOMElement: HTMLElement | Text | undefined;\n  offset: number;\n\n  render(): ReactElement;\n  emit(fiberEventName: FiberEventName, actionPayload?: ActionPayload): void;\n  updateProps(props: object): void;\n  setState(state: object): void;\n  componentDidMount: () => Promise<VoidFunction>;\n  componentWillUnmount: () => Promise<VoidFunction>;\n  mount(hostDOMElement: HTMLElement, positionIndex?: number | null): void;\n  unmount(): void;\n}\n\nexport { createComponent, type ClassComponent, type ComponentInstance };\n"],"names":["VDOMType","ARRAY_DIFF_OP","withoutNulls","children","filter","child","Node","TEXT_NODE","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","ArrayWithOriginalIndices","array","originalIndices","equalsFn","constructor","this","map","_","index","length","originalIndexAt","findIndexFrom","item","fromIndex","wasElementRemoved","newArray","findIndex","newItem","wasElementTheSame","wasElementAdded","removeItemAction","operation","op","REMOVE","splice","noopItemAction","NOOP","originalIndex","addItemAction","ADD","moveItemAction","toIndex","MOVE","from","_item","removeRestItems","operations","push","createElement","tag","props","type","ELEMENT","mapTextNodes","COMPONENT","text","TEXT","value","attachEventListener","domEventName","emitGenerator","domElement","parentFiberInstance","boundContextToDOMEvent","args","apply","addEventListener","isScheduled","jobs","enqueueJob","job","queueMicrotask","processJobs","scheduleUpdate","shift","result","Promise","resolve","then","error","console","destroyDOM","vNode","remove","removeTextNode","listeners","forEach","attachedDOMEventListeners","Object","entries","domEventWithContext","removeEventListener","removeEventListeners","removeElementNode","FRAGMENT","removeFragmentNodes","fiberInstance","unmount","componentWillUnmount","Error","setProp","class","className","style","restAttrs","Array","isArray","classList","add","setClass","key","setStyle","setValueForAttribute","removeStyle","removeValueForAttribute","startsWith","setAttribute","String","removeAttribute","extractPropsAndEvents","on","eventMap","mountDOM","parentDOMElement","positionIndex","undefined","domTextNode","document","createTextNode","insertIntoDOM","createDOMElementFromTextNode","domEventMap","listener","attachEventListeners","setInitialProperties","createDOMElementFromElementNode","createDOMElementFromFragmentNode","ClassComponent","fiberEventMap","mount","firstDOMElement","createDOMElementFromFiberNode","componentDidMount","appendChild","childNodes","insertBefore","extractChildren","createApp","RootComponent","isMounted","rootVNode","_parentDOMElement","Dispatcher","actionSubscriptions","Map","afterHandlers","subscribe","actionName","reducerWithInjectedState","has","set","reducers","get","includes","indexOf","afterEveryCommand","afterHandler","dispatch","actionPayload","reducer","warn","objectsDiff","oldObject","newObject","oldKeys","keys","newKeys","added","newKey","removed","oldKey","updated","hasOwnProperty","obj","prop","prototype","call","isNotBlankOrEmptyString","str","isNotEmptyString","trim","areVNodesEqual","vNodeA","vNodeB","tagA","keyA","tagB","keyB","patchDOM","oldVNode","newVNode","parentDOMNode","findIndexInParent","oldText","newText","nodeValue","patchText","parentFiber","HTMLElement","oldClass","oldStyle","oldOnEvents","oldRestAttributes","newClass","newStyle","newOnEvents","newRestAttributes","oldListeners","patchAttributes","concat","patchClasses","oldClasses","toClassList","newClasses","oldArray","newArrayItem","oldArrayItem","classes","split","patchStyles","patchEvents","addedListeners","eventType","patchElement","oldFiberInstance","newProps","updateProps","patchFiber","oldChildren","newChildren","parentDomElement","diffSequence","a","b","sequence","arraysDiffSequence","offset","oldChild","newChild","domElementAtTargetPosition","patchChildren","voidFunction","createComponent","render","state","methods","Fiber","fiberListeners","dispatcher","unSubscriptions","domElements","flatMap","emit","fiberEventName","patch","setState","hostDOMElement","wireFiberEventListeners","unsubscribe","nextVNode","wireFiberEventListener","payload","fiberEmitGenerator","methodName"],"mappings":"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"}